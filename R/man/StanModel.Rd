% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bridgestan.R
\name{StanModel}
\alias{StanModel}
\title{StanModel
A class for connecting to BridgeStan compiled models.}
\description{
StanModel
A class for connecting to BridgeStan compiled models.

StanModel
A class for connecting to BridgeStan compiled models.
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-StanModel-new}{\code{StanModel$new()}}
\item \href{#method-StanModel-name}{\code{StanModel$name()}}
\item \href{#method-StanModel-param_names}{\code{StanModel$param_names()}}
\item \href{#method-StanModel-param_unc_names}{\code{StanModel$param_unc_names()}}
\item \href{#method-StanModel-param_num}{\code{StanModel$param_num()}}
\item \href{#method-StanModel-param_unc_num}{\code{StanModel$param_unc_num()}}
\item \href{#method-StanModel-param_constrain}{\code{StanModel$param_constrain()}}
\item \href{#method-StanModel-param_unconstrain}{\code{StanModel$param_unconstrain()}}
\item \href{#method-StanModel-param_unconstrain_json}{\code{StanModel$param_unconstrain_json()}}
\item \href{#method-StanModel-log_density}{\code{StanModel$log_density()}}
\item \href{#method-StanModel-log_density_gradient}{\code{StanModel$log_density_gradient()}}
\item \href{#method-StanModel-log_density_hessian}{\code{StanModel$log_density_hessian()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-new"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-new}{}}}
\subsection{Method \code{new()}}{
Create a Stan Model instace.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$new(lib, data, rng_seed, chain_id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{lib}}{A path to a compiled Bridgestan Shared Object file.}

\item{\code{data}}{A path to a JSON data file for the model.}

\item{\code{rng_seed}}{Seed for the RNG in the model object.}

\item{\code{chain_id}}{Used to offset the RNG by a fixed amount.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new StanModel.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-name"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-name}{}}}
\subsection{Method \code{name()}}{
Get the name of this StanModel
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$name()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A character vector of the name.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-param_names"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-param_names}{}}}
\subsection{Method \code{param_names()}}{
Return the indexed names of the (constrained) parameters.
For containers, indexes are separated by periods (.).

For example, the scalar a has indexed name a, the vector entry a[1] has
indexed name a.1 and the matrix entry a[2, 3] has indexed name a.2.3. Parameter
order of the output is column major and more generally last-index major for containers.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$param_names(include_tp = FALSE, include_gq = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{include_tp}}{Whether to include variables from transformed parameters.}

\item{\code{include_gq}}{Whether to include variables from generated quantities.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of character vectors of the names.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-param_unc_names"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-param_unc_names}{}}}
\subsection{Method \code{param_unc_names()}}{
Return the indexed names of the unconstrained parameters.
For containers, indexes are separated by periods (.).

For example, the scalar a has indexed name a, the vector entry a[1] has
indexed name a.1 and the matrix entry a[2, 3] has indexed name a.2.3. Parameter
order of the output is column major and more generally last-index major for containers.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$param_unc_names()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list of character vectors of the names.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-param_num"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-param_num}{}}}
\subsection{Method \code{param_num()}}{
Return the number of (constrained) parameters in the model.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$param_num(include_tp = FALSE, include_gq = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{include_tp}}{Whether to include variables from transformed parameters.}

\item{\code{include_gq}}{Whether to include variables from generated quantities.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The number of parameters in the model.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-param_unc_num"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-param_unc_num}{}}}
\subsection{Method \code{param_unc_num()}}{
Return the number of unconstrained parameters in the model.
'
This function is mainly different from `param_num` when variables are declared with constraints.
For example, `simplex[5]` has a constrained size of 5, but an unconstrained size of 4.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$param_unc_num()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The number of parameters in the model.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-param_constrain"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-param_constrain}{}}}
\subsection{Method \code{param_constrain()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$param_constrain(theta_unc, include_tp = FALSE, include_gq = FALSE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-param_unconstrain"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-param_unconstrain}{}}}
\subsection{Method \code{param_unconstrain()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$param_unconstrain(theta)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-param_unconstrain_json"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-param_unconstrain_json}{}}}
\subsection{Method \code{param_unconstrain_json()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$param_unconstrain_json(json)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-log_density"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-log_density}{}}}
\subsection{Method \code{log_density()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$log_density(theta, propto = TRUE, jacobian = TRUE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-log_density_gradient"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-log_density_gradient}{}}}
\subsection{Method \code{log_density_gradient()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$log_density_gradient(theta, propto = TRUE, jacobian = TRUE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-log_density_hessian"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-log_density_hessian}{}}}
\subsection{Method \code{log_density_hessian()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$log_density_hessian(theta, propto = TRUE, jacobian = TRUE)}\if{html}{\out{</div>}}
}

}
}
